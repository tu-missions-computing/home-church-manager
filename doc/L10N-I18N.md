Internationalization and Localization
=====================================

*Internationalization* (abbreviated `I18N`) refers to making a program
that can support different human languages. Of course, I18N includes
text, but also includes formats for dates, numbers, currency, and so
forth.

*Localization* (abbreviated `L10N`) refers to providing information to
an internationalized program that allow it to use a new human language.

A *locale* refers to the a particular set of language and cultural
conventions for a particular country. A locale has the form `ll_CC`,
where `ll` is an [ISO 639 two-letter language
code](https://en.wikipedia.org/wiki/ISO_639), and `CC` is an [ISO 3166
two-letter country code](https://en.wikipedia.org/wiki/ISO_3166). For
example `en_US` refers to US English, and `en_GB` refers to British
English. If the country code is not important, it can be dropped. For
example `en` refers to English without reference to a particular
country, `es` (for "Español") refers similarly to Spanish, and `de` (for
"Deutsch") to German.

We refer to the *source* language, which is the human language in which
text in a program is written originally. For our work, the *source*
langauge will always be English. In contrast, a *target* language is the
human language into which we wish to translate the text in a program
(e.g., Spanish)

Set Up
======

-   Make sure the `Flask-Babel` package is installed. There are several
    variants of this package; be sure you get the "original" by name.

I18N
====

The `Flask-Babel` package allows you to internationalize and localize
both source files and Flask (Jinja) templates.

Code
----

To internationalize a program, we identify all the text that must be
translated into a different locale. Consider the following function:

    def say_hello():
       return "Hello, world"

Of course, we want to be able to translate `Hello, world` into other
languages. To indicate this fact to Python, we wrap the string with the
`gettext` function.

    def say_hello():
       return gettext("Hello, world")

Think of `gettext` as marking the string as one that will be subject to
translation. At run time, `gettext` uses the current *locale* to render
a translated version of the string. Unless we configure our program
otherwise, the `gettext` will simply return the original text.

As you might imagine, if there are a lot of places in your program that
need to be translated, it would quickly get tedious to keep typing
`gettext`. Instead, the usual convention is to create a function that
does the same thing and give it the name `_`. Although naming a function
"underscore" seems strange, it’s a completely legitimate Python function
name, and has the advantage of being short and unassuming. With this
definition available, we can rewrite our function function as:

    def say_hello():
       return _("Hello, world")

Yes, it looks weird, but it works fine.

Templates
---------

To internationalize templates, you use the same "underscore" syntax we
just discussed. For example:

    {% block content %}
        <h1>{{ _('Welcome to') }} Examples:I18N-L10N</h1>

        <p>{{ _("Here are some messages") }}:</p>
        <ul>
        {% for message in messages %}
            <li>{{ message }}</li>
        {% endfor %}
        </ul>
    {% endblock %}

Note that the "underscore" functions *must* appear within double
mustaches in order to be interpreted by Python as a function call. If
you omit the `{{ ... }}` syntax, the underscore function will *not* be
recognized and you’ll see the function call show up in the rendered
HTML.

Files
=====

To understand the next step (localization), you need to be aware of
three types of files.

1.  A *Portable Object* file (`.po` extension) is an ordinary text file
    that associates text in the source language with translated text in
    the target language. There is one `.po` file for every language into
    which the program has been localized.

2.  A *Portable Object Template* file (`.pot` extension) is a `.po` file
    that is not specific to a translation. This file is usually created
    by extracting text strings from the program code and forms the basis
    for the `.po` files for each target language.

3.  A *Machine Object* file (`.mo` extension) is a binary file intended
    to be read by programs, not people. Using the `pybabel` utility
    program, we convert a `.po` file into the corresponding `.mo` file,
    which is used by the program at run time to render text in the
    target language.

L10N
====

Once we’ve *internationalized* our program, we’re ready for
*localization*. We’ll use the `pybabel` command, which comes with
`Flask-Babel` and is documented more thoroughly below. Here are the
steps:

1.  Run the `pybabel extract` command, which sifts through your code to
    find all the places where you’ve included a call to `gettext` (or
    `_`). The `pybabel` program will create a `.pot` file containing
    information on all the text strings that will have to be translated.

2.  Run the `pybabel init` command to create a `.po` file for a target
    language.

3.  Update the `.po` file with the proper translations of all the text
    in your program. This is the hard part.

4.  Run the `pybabel compile` command, which converts your `.po` file(s)
    into the associated `.mo` file(s). The latter files are used by your
    program at run time to render text in the appropriate langauge.

PyBabel Command
===============

Here are the details of the `pybabel` command, used to manipulate `.po`,
`.mo`, and `.pot` files. The command is run from the *command line*.

Extract text from source code (according to `babel.cfg` configuration
file) into the portable object template file called `messages.pot`.

    pybabel extract -F babel.cfg -o messages.pot .

Based on the `messages.pot` file, create a portable object file for
Spanish (`es`). This file is where the Spanish translation of the text
in the program will be create. The file will be created in the
`translations` directory.

    pybabel init -i messages.pot -d translations -l es

Compile translations for use. This command finds all portable object
(`.po`) files and generates machine object (`.mo`) files that are used
by the program at run time.

    pybabel compile -d translations

Update all existing `.po` files to reflect changes in the main
`messages.pot` file. Note that you *do not* want to run the `init`
command (above), because it would overwrite all the translations already
in the `.po` files! This command updates the `.po` files with *new* text
from the `.pot` file *without* deleting existing entries.

    pybabel update -i messages.pot -d translations

Running a Localized Program
===========================

There are various ways to configure your program to execute while using
a given locale. One simple way uses the `app.config` dictionary to
configure Babel. For example, to render text in Spanish:

    app.config['BABEL_DEFAULT_LOCALE'] = 'es'

When the program runs, all strings decorated with `gettext` (or
"underscore") will be translated to the localized version from the
appropriate `.mo` file (e.g., `es.mo` for Spanish). Note that
localization uses the (binary) `.mo` file, and *not* the (human-redable)
`.po` file. If you are not seeing the proper translated text, you may
have forgotten to run the `pybabel compile` command.

Links
=====

These links may help.

Reference Material
------------------

-   [Flask Babel](https://pythonhosted.org/Flask-Babel/)

-   [Babel](http://babel.pocoo.org/en/latest/)

-   [Python gettext
    Library](https://docs.python.org/2.7/library/gettext.html), which
    wraps the Gnu library

-   [Gnu gettext Library](https://www.gnu.org/software/gettext/), on
    which all this is based

Tutorials
---------

-   [Tutorial on
    Flask-Babel](https://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-xiv-i18n-and-l10n)

-   [Flask I18N
    Tutorial](http://damyanon.net/flask-series-internationalization/)

-   [L10N for Flask
    Applications](http://phraseapp.com/blog/posts/python-localization-for-flask-applications/)

-   [Flask I18N and
    L10N](http://www.safaribooksonline.com/blog/2013/11/27/flask-internationalization-and-localization/)
